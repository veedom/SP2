.extern printf
.data  					/* сегмент данных */

arr:
	.long 1, 2, -40, -122, -150, 133, -100, 144, -111, -55
arr_end:
	A:
		.long 100
	B:
		.long 150
print_sum:
	.string "Сумма положительных байтов массива между A и B: %d\n"
print_of:
	.string "Переполнение! %d\n"

.text				/* сегмент кода*/
.global main			/* main - глобальная переменная */
.type main, @function		/* main - функция */

main:
	movl $arr, %ebx		/* в %ebx адрес первого эл-та массива; */
        movl A, %edx 		/* в %edx будем хранить число A; */
        movl B, %esi 		/* в %esi будем хранить число B; */
        movl $0, %eax  		/* в %eax будем хранить сумму; */

start:
	cmpl $0, %ebx		/* сравниваем число 0 с элементом массива; */
	js next			/* переход, если число отрицательное; */
	cmpl %edx,(%ebx) 	/* сравниваем число A с элементами массива; */
	jg less 		/* переход, если первый операнд меньше второго; */
        jl next 		/* переход, если первый операнд больше второго; */
        je equally 		/* переход, если операнды равны; */

less:
	cmpl %esi,(%ebx) 	/* сравниваем число B с элементами массива; */
	jg next 		/* переход к след элементу, если первый операнд меньше второго; */
        jl sum 			/* + к сумме, если первый операнд больше второго; */
        je equally 		/* + к сумме, если операнды равны; */

equally:
	addl (%ebx),%eax 	/* значение текущего эл-та добавляем в сумму; */
	jo msg_of
	jc msg_of
	jmp next

sum:
        addl (%ebx),%eax 	/* значение текущего эл-та добавляем в сумму; */
	jo msg_of
	jc msg_of
	jmp next

next:
	addl  $4, %ebx 		/* переходим к адресу след эл-та массива; */
        jmp count		/* безусловный переход; */

count:
	cmpl $arr_end, %ebx 	/* сравнить адрес текущего элемента и адрес конца массива*/
 	jne start 		/* если не равны, то повторить цикл снова*/
				/* выводим сумму положительных байтов массива */
	push %eax
	push $print_sum
	call  printf
	addl  $8, %esp
	movl  $0, %eax
	ret

msg_of:				/* выводим сообщение о переполнении; */
	push $print_of
	call  printf
	addl  $8, %esp
	movl  $0, %eax
	ret

